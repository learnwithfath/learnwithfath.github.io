
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Go Concurrency &amp; Goroutines</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="go-concurrency-goroutines"
                  title="Go Concurrency &amp; Goroutines"
                  environment="web"
                  feedback-link="https://github.com/learnwithfath/feedback">
    
      <google-codelab-step label="Pengenalan" duration="3">
        <p>Selamat datang! Concurrency adalah salah satu fitur paling powerful di Go. Tutorial ini akan mengajarkan cara menulis concurrent programs yang efficient.</p>
<h2 is-upgraded>Apa yang Akan Anda Pelajari</h2>
<ul>
<li>Goroutines</li>
<li>Channels</li>
<li>Select statement</li>
<li>Buffered channels</li>
<li>Channel directions</li>
<li>Worker pools</li>
<li>Context package</li>
<li>Common patterns</li>
<li>Race conditions</li>
</ul>
<h2 is-upgraded>Prasyarat</h2>
<ul>
<li>Tutorial &#34;Go Dasar untuk Pemula&#34;</li>
<li>Pemahaman dasar tentang concurrency</li>
<li>Go 1.16+ terinstall</li>
</ul>
<p>Positive : Concurrency di Go jauh lebih mudah dibanding bahasa lain!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Goroutines Basics" duration="15">
        <p>Goroutines adalah lightweight threads yang dikelola oleh Go runtime.</p>
<h2 is-upgraded>Goroutine Pertama</h2>
<pre><code language="language-go" class="language-go">package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

func sayHello() {
    fmt.Println(&#34;Hello from goroutine!&#34;)
}

func main() {
    // Jalankan function biasa
    sayHello()
    
    // Jalankan sebagai goroutine
    go sayHello()
    
    // Wait agar goroutine selesai
    time.Sleep(time.Second)
    
    fmt.Println(&#34;Main function ends&#34;)
}
</code></pre>
<h2 is-upgraded>Anonymous Goroutines</h2>
<pre><code language="language-go" class="language-go">func main() {
    // Anonymous function sebagai goroutine
    go func() {
        fmt.Println(&#34;Anonymous goroutine&#34;)
    }()
    
    // Dengan parameter
    go func(msg string) {
        fmt.Println(msg)
    }(&#34;Hello from parameter&#34;)
    
    time.Sleep(time.Second)
}
</code></pre>
<h2 is-upgraded>Multiple Goroutines</h2>
<pre><code language="language-go" class="language-go">func printNumbers() {
    for i := 1; i &lt;= 5; i++ {
        fmt.Printf(&#34;Number: %d\n&#34;, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func printLetters() {
    for i := &#39;a&#39;; i &lt;= &#39;e&#39;; i++ {
        fmt.Printf(&#34;Letter: %c\n&#34;, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    go printNumbers()
    go printLetters()
    
    time.Sleep(time.Second)
    fmt.Println(&#34;Done&#34;)
}
</code></pre>
<h2 is-upgraded>Goroutine Properties</h2>
<ul>
<li><strong>Lightweight</strong> - Hanya butuh ~2KB memory</li>
<li><strong>Cheap</strong> - Bisa buat ribuan goroutines</li>
<li><strong>Managed</strong> - Go runtime handle scheduling</li>
<li><strong>Non-blocking</strong> - Tidak block main thread</li>
</ul>
<p>Negative : Jangan gunakan time.Sleep untuk synchronization! Gunakan channels.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Channels" duration="20">
        <p>Channels adalah cara goroutines berkomunikasi.</p>
<h2 is-upgraded>Channel Basics</h2>
<pre><code language="language-go" class="language-go">func main() {
    // Buat channel
    ch := make(chan string)
    
    // Send ke channel (di goroutine)
    go func() {
        ch &lt;- &#34;Hello from channel&#34;
    }()
    
    // Receive dari channel
    msg := &lt;-ch
    fmt.Println(msg)
}
</code></pre>
<h2 is-upgraded>Channel Operations</h2>
<pre><code language="language-go" class="language-go">// Buat channel
ch := make(chan int)

// Send (akan block sampai ada receiver)
ch &lt;- 42

// Receive (akan block sampai ada sender)
value := &lt;-ch

// Receive dan ignore value
&lt;-ch

// Close channel
close(ch)

// Check if closed
value, ok := &lt;-ch
if !ok {
    fmt.Println(&#34;Channel closed&#34;)
}
</code></pre>
<h2 is-upgraded>Bidirectional Communication</h2>
<pre><code language="language-go" class="language-go">func worker(input chan int, output chan int) {
    for num := range input {
        output &lt;- num * 2
    }
    close(output)
}

func main() {
    input := make(chan int)
    output := make(chan int)
    
    go worker(input, output)
    
    // Send data
    go func() {
        for i := 1; i &lt;= 5; i++ {
            input &lt;- i
        }
        close(input)
    }()
    
    // Receive results
    for result := range output {
        fmt.Println(result)
    }
}
</code></pre>
<h2 is-upgraded>Range over Channel</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch := make(chan int)
    
    go func() {
        for i := 1; i &lt;= 5; i++ {
            ch &lt;- i
        }
        close(ch)
    }()
    
    // Range akan loop sampai channel closed
    for num := range ch {
        fmt.Println(num)
    }
}
</code></pre>
<p>Positive : Channels membuat concurrent programming aman dan mudah!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Buffered Channels" duration="15">
        <p>Buffered channels punya kapasitas untuk menyimpan values.</p>
<h2 is-upgraded>Unbuffered vs Buffered</h2>
<pre><code language="language-go" class="language-go">// Unbuffered - block sampai ada receiver
ch1 := make(chan int)

// Buffered - tidak block sampai buffer penuh
ch2 := make(chan int, 3)
</code></pre>
<h2 is-upgraded>Buffered Channel Example</h2>
<pre><code language="language-go" class="language-go">func main() {
    // Buffer size 3
    ch := make(chan string, 3)
    
    // Send tanpa goroutine (tidak block karena ada buffer)
    ch &lt;- &#34;first&#34;
    ch &lt;- &#34;second&#34;
    ch &lt;- &#34;third&#34;
    
    // Receive
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}
</code></pre>
<h2 is-upgraded>Buffer Full</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch := make(chan int, 2)
    
    ch &lt;- 1
    ch &lt;- 2
    // ch &lt;- 3  // Akan deadlock! Buffer penuh
    
    fmt.Println(&lt;-ch)
    ch &lt;- 3  // Sekarang bisa, ada space
    
    fmt.Println(&lt;-ch)
    fmt.Println(&lt;-ch)
}
</code></pre>
<h2 is-upgraded>Practical Example</h2>
<pre><code language="language-go" class="language-go">func processJobs(jobs chan int, results chan int) {
    for job := range jobs {
        // Simulate processing
        time.Sleep(100 * time.Millisecond)
        results &lt;- job * 2
    }
}

func main() {
    jobs := make(chan int, 10)
    results := make(chan int, 10)
    
    // Start 3 workers
    for w := 1; w &lt;= 3; w++ {
        go processJobs(jobs, results)
    }
    
    // Send jobs
    for j := 1; j &lt;= 9; j++ {
        jobs &lt;- j
    }
    close(jobs)
    
    // Collect results
    for a := 1; a &lt;= 9; a++ {
        fmt.Println(&lt;-results)
    }
}
</code></pre>
<h2 is-upgraded>Buffer Size Guidelines</h2>
<pre><code language="language-go" class="language-go">// Small buffer (1-10) - untuk coordination
ch := make(chan int, 5)

// Medium buffer (10-100) - untuk batching
ch := make(chan Task, 50)

// Large buffer (100+) - untuk high throughput
ch := make(chan Message, 1000)
</code></pre>
<p>Negative : Buffer terlalu besar bisa waste memory. Mulai dengan unbuffered, tambah buffer jika perlu.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Select Statement" duration="15">
        <p>Select memungkinkan goroutine menunggu multiple channel operations.</p>
<h2 is-upgraded>Basic Select</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 &lt;- &#34;from channel 1&#34;
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 &lt;- &#34;from channel 2&#34;
    }()
    
    // Select akan execute case yang ready duluan
    select {
    case msg1 := &lt;-ch1:
        fmt.Println(msg1)
    case msg2 := &lt;-ch2:
        fmt.Println(msg2)
    }
}
</code></pre>
<h2 is-upgraded>Select dengan Multiple Cases</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        for {
            ch1 &lt;- &#34;from 1&#34;
            time.Sleep(500 * time.Millisecond)
        }
    }()
    
    go func() {
        for {
            ch2 &lt;- &#34;from 2&#34;
            time.Sleep(700 * time.Millisecond)
        }
    }()
    
    for i := 0; i &lt; 5; i++ {
        select {
        case msg1 := &lt;-ch1:
            fmt.Println(msg1)
        case msg2 := &lt;-ch2:
            fmt.Println(msg2)
        }
    }
}
</code></pre>
<h2 is-upgraded>Default Case</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch := make(chan string)
    
    select {
    case msg := &lt;-ch:
        fmt.Println(msg)
    default:
        fmt.Println(&#34;No message received&#34;)
    }
}
</code></pre>
<h2 is-upgraded>Timeout Pattern</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch &lt;- &#34;result&#34;
    }()
    
    select {
    case result := &lt;-ch:
        fmt.Println(result)
    case &lt;-time.After(1 * time.Second):
        fmt.Println(&#34;Timeout!&#34;)
    }
}
</code></pre>
<h2 is-upgraded>Non-blocking Send/Receive</h2>
<pre><code language="language-go" class="language-go">func main() {
    ch := make(chan int, 1)
    
    // Non-blocking send
    select {
    case ch &lt;- 42:
        fmt.Println(&#34;Sent&#34;)
    default:
        fmt.Println(&#34;Channel full&#34;)
    }
    
    // Non-blocking receive
    select {
    case val := &lt;-ch:
        fmt.Println(&#34;Received:&#34;, val)
    default:
        fmt.Println(&#34;No value&#34;)
    }
}
</code></pre>
<p>Positive : Select adalah tool yang sangat powerful untuk handle multiple channels!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Channel Directions" duration="10">
        <p>Specify apakah channel untuk send-only atau receive-only.</p>
<h2 is-upgraded>Send-only Channel</h2>
<pre><code language="language-go" class="language-go">func sendData(ch chan&lt;- int) {
    ch &lt;- 42
    // val := &lt;-ch  // Error! Send-only
}
</code></pre>
<h2 is-upgraded>Receive-only Channel</h2>
<pre><code language="language-go" class="language-go">func receiveData(ch &lt;-chan int) {
    val := &lt;-ch
    fmt.Println(val)
    // ch &lt;- 42  // Error! Receive-only
}
</code></pre>
<h2 is-upgraded>Complete Example</h2>
<pre><code language="language-go" class="language-go">func producer(ch chan&lt;- int) {
    for i := 1; i &lt;= 5; i++ {
        ch &lt;- i
        fmt.Printf(&#34;Produced: %d\n&#34;, i)
    }
    close(ch)
}

func consumer(ch &lt;-chan int) {
    for num := range ch {
        fmt.Printf(&#34;Consumed: %d\n&#34;, num)
    }
}

func main() {
    ch := make(chan int)
    
    go producer(ch)
    consumer(ch)
}
</code></pre>
<h2 is-upgraded>Benefits</h2>
<ol type="1">
<li><strong>Type safety</strong> - Compile-time checking</li>
<li><strong>Clear intent</strong> - Dokumentasi yang jelas</li>
<li><strong>Prevent mistakes</strong> - Tidak bisa salah gunakan channel</li>
</ol>
<pre><code language="language-go" class="language-go">// Good practice
func process(input &lt;-chan Task, output chan&lt;- Result) {
    for task := range input {
        result := doWork(task)
        output &lt;- result
    }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Worker Pool Pattern" duration="20">
        <p>Worker pool adalah pattern untuk process tasks concurrently dengan jumlah workers terbatas.</p>
<h2 is-upgraded>Basic Worker Pool</h2>
<pre><code language="language-go" class="language-go">package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

type Job struct {
    ID     int
    Data   string
}

type Result struct {
    JobID  int
    Output string
}

func worker(id int, jobs &lt;-chan Job, results chan&lt;- Result) {
    for job := range jobs {
        fmt.Printf(&#34;Worker %d started job %d\n&#34;, id, job.ID)
        
        // Simulate work
        time.Sleep(time.Second)
        
        result := Result{
            JobID:  job.ID,
            Output: fmt.Sprintf(&#34;Processed: %s&#34;, job.Data),
        }
        
        results &lt;- result
        fmt.Printf(&#34;Worker %d finished job %d\n&#34;, id, job.ID)
    }
}

func main() {
    numWorkers := 3
    numJobs := 9
    
    jobs := make(chan Job, numJobs)
    results := make(chan Result, numJobs)
    
    // Start workers
    for w := 1; w &lt;= numWorkers; w++ {
        go worker(w, jobs, results)
    }
    
    // Send jobs
    for j := 1; j &lt;= numJobs; j++ {
        jobs &lt;- Job{
            ID:   j,
            Data: fmt.Sprintf(&#34;task-%d&#34;, j),
        }
    }
    close(jobs)
    
    // Collect results
    for a := 1; a &lt;= numJobs; a++ {
        result := &lt;-results
        fmt.Printf(&#34;Result: Job %d - %s\n&#34;, result.JobID, result.Output)
    }
}
</code></pre>
<h2 is-upgraded>Advanced Worker Pool</h2>
<pre><code language="language-go" class="language-go">type WorkerPool struct {
    numWorkers int
    jobs       chan Job
    results    chan Result
    done       chan bool
}

func NewWorkerPool(numWorkers, bufferSize int) *WorkerPool {
    return &amp;WorkerPool{
        numWorkers: numWorkers,
        jobs:       make(chan Job, bufferSize),
        results:    make(chan Result, bufferSize),
        done:       make(chan bool),
    }
}

func (wp *WorkerPool) Start() {
    for i := 1; i &lt;= wp.numWorkers; i++ {
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    for job := range wp.jobs {
        fmt.Printf(&#34;Worker %d processing job %d\n&#34;, id, job.ID)
        time.Sleep(time.Second)
        
        wp.results &lt;- Result{
            JobID:  job.ID,
            Output: fmt.Sprintf(&#34;Done: %s&#34;, job.Data),
        }
    }
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobs &lt;- job
}

func (wp *WorkerPool) Close() {
    close(wp.jobs)
}

func (wp *WorkerPool) Results() &lt;-chan Result {
    return wp.results
}
</code></pre>
<h2 is-upgraded>Usage</h2>
<pre><code language="language-go" class="language-go">func main() {
    pool := NewWorkerPool(5, 100)
    pool.Start()
    
    // Submit jobs
    go func() {
        for i := 1; i &lt;= 20; i++ {
            pool.Submit(Job{
                ID:   i,
                Data: fmt.Sprintf(&#34;task-%d&#34;, i),
            })
        }
        pool.Close()
    }()
    
    // Process results
    for i := 1; i &lt;= 20; i++ {
        result := &lt;-pool.Results()
        fmt.Println(result.Output)
    }
}
</code></pre>
<p>Positive : Worker pools efisien untuk process banyak tasks dengan resource terbatas!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Context Package" duration="15">
        <p>Context untuk cancellation, timeouts, dan passing values.</p>
<h2 is-upgraded>Context Basics</h2>
<pre><code language="language-go" class="language-go">import &#34;context&#34;

func main() {
    // Background context
    ctx := context.Background()
    
    // TODO context (placeholder)
    ctx = context.TODO()
}
</code></pre>
<h2 is-upgraded>WithCancel</h2>
<pre><code language="language-go" class="language-go">func worker(ctx context.Context, id int) {
    for {
        select {
        case &lt;-ctx.Done():
            fmt.Printf(&#34;Worker %d cancelled\n&#34;, id)
            return
        default:
            fmt.Printf(&#34;Worker %d working...\n&#34;, id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    
    for i := 1; i &lt;= 3; i++ {
        go worker(ctx, i)
    }
    
    time.Sleep(2 * time.Second)
    cancel()  // Cancel all workers
    
    time.Sleep(time.Second)
}
</code></pre>
<h2 is-upgraded>WithTimeout</h2>
<pre><code language="language-go" class="language-go">func fetchData(ctx context.Context) error {
    select {
    case &lt;-time.After(2 * time.Second):
        return nil
    case &lt;-ctx.Done():
        return ctx.Err()
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    if err := fetchData(ctx); err != nil {
        fmt.Println(&#34;Error:&#34;, err)  // context deadline exceeded
    }
}
</code></pre>
<h2 is-upgraded>WithDeadline</h2>
<pre><code language="language-go" class="language-go">func main() {
    deadline := time.Now().Add(3 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
    
    select {
    case &lt;-time.After(5 * time.Second):
        fmt.Println(&#34;Work done&#34;)
    case &lt;-ctx.Done():
        fmt.Println(&#34;Deadline exceeded:&#34;, ctx.Err())
    }
}
</code></pre>
<h2 is-upgraded>WithValue</h2>
<pre><code language="language-go" class="language-go">func worker(ctx context.Context) {
    userID := ctx.Value(&#34;userID&#34;)
    requestID := ctx.Value(&#34;requestID&#34;)
    
    fmt.Printf(&#34;User: %v, Request: %v\n&#34;, userID, requestID)
}

func main() {
    ctx := context.Background()
    ctx = context.WithValue(ctx, &#34;userID&#34;, 123)
    ctx = context.WithValue(ctx, &#34;requestID&#34;, &#34;abc-123&#34;)
    
    worker(ctx)
}
</code></pre>
<p>Negative : Jangan overuse WithValue! Hanya untuk request-scoped data.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Race Conditions" duration="15">
        <p>Race conditions terjadi ketika multiple goroutines akses shared data.</p>
<h2 is-upgraded>Race Condition Example</h2>
<pre><code language="language-go" class="language-go">package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

var counter = 0

func increment() {
    counter++
}

func main() {
    for i := 0; i &lt; 1000; i++ {
        go increment()
    }
    
    time.Sleep(time.Second)
    fmt.Println(&#34;Counter:&#34;, counter)  // Tidak selalu 1000!
}
</code></pre>
<h2 is-upgraded>Detect Race Conditions</h2>
<pre><code language="language-bash" class="language-bash">go run -race main.go
</code></pre>
<h2 is-upgraded>Solution 1: Mutex</h2>
<pre><code language="language-go" class="language-go">import &#34;sync&#34;

var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}
</code></pre>
<h2 is-upgraded>Solution 2: Atomic Operations</h2>
<pre><code language="language-go" class="language-go">import &#34;sync/atomic&#34;

var counter int64

func increment() {
    atomic.AddInt64(&amp;counter, 1)
}
</code></pre>
<h2 is-upgraded>Solution 3: Channels</h2>
<pre><code language="language-go" class="language-go">func main() {
    counter := 0
    ch := make(chan int)
    
    // Goroutine untuk update counter
    go func() {
        for range ch {
            counter++
        }
    }()
    
    // Send 1000 increments
    for i := 0; i &lt; 1000; i++ {
        ch &lt;- 1
    }
    
    close(ch)
    time.Sleep(time.Millisecond)
    fmt.Println(&#34;Counter:&#34;, counter)
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Common Patterns" duration="15">
        <p>Pattern-pattern yang sering digunakan dalam concurrent Go.</p>
<h2 is-upgraded>Fan-Out, Fan-In</h2>
<pre><code language="language-go" class="language-go">func producer(nums ...int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out &lt;- n
        }
        close(out)
    }()
    return out
}

func square(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out &lt;- n * n
        }
        close(out)
    }()
    return out
}

func merge(cs ...&lt;-chan int) &lt;-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, c := range cs {
        wg.Add(1)
        go func(ch &lt;-chan int) {
            defer wg.Done()
            for n := range ch {
                out &lt;- n
            }
        }(c)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}

func main() {
    in := producer(1, 2, 3, 4, 5)
    
    // Fan-out
    c1 := square(in)
    c2 := square(in)
    
    // Fan-in
    for n := range merge(c1, c2) {
        fmt.Println(n)
    }
}
</code></pre>
<h2 is-upgraded>Pipeline Pattern</h2>
<pre><code language="language-go" class="language-go">func gen(nums ...int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out &lt;- n
        }
        close(out)
    }()
    return out
}

func sq(in &lt;-chan int) &lt;-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out &lt;- n * n
        }
        close(out)
    }()
    return out
}

func main() {
    // Pipeline: gen -&gt; sq -&gt; sq
    for n := range sq(sq(gen(2, 3, 4))) {
        fmt.Println(n)
    }
}
</code></pre>
<h2 is-upgraded>Rate Limiting</h2>
<pre><code language="language-go" class="language-go">func main() {
    requests := make(chan int, 5)
    for i := 1; i &lt;= 5; i++ {
        requests &lt;- i
    }
    close(requests)
    
    limiter := time.Tick(200 * time.Millisecond)
    
    for req := range requests {
        &lt;-limiter
        fmt.Println(&#34;Request&#34;, req, time.Now())
    }
}
</code></pre>
<p>Positive : Patterns ini membuat concurrent code lebih maintainable!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Project: Concurrent Web Scraper" duration="30">
        <p>Mari buat web scraper concurrent yang efficient!</p>
<pre><code language="language-go" class="language-go">package main

import (
    &#34;fmt&#34;
    &#34;io&#34;
    &#34;net/http&#34;
    &#34;sync&#34;
    &#34;time&#34;
)

type Result struct {
    URL    string
    Status int
    Size   int
    Error  error
}

func fetch(url string) Result {
    start := time.Now()
    
    resp, err := http.Get(url)
    if err != nil {
        return Result{URL: url, Error: err}
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return Result{URL: url, Status: resp.StatusCode, Error: err}
    }
    
    fmt.Printf(&#34;Fetched %s in %v\n&#34;, url, time.Since(start))
    
    return Result{
        URL:    url,
        Status: resp.StatusCode,
        Size:   len(body),
    }
}

func worker(id int, urls &lt;-chan string, results chan&lt;- Result, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for url := range urls {
        fmt.Printf(&#34;Worker %d fetching %s\n&#34;, id, url)
        result := fetch(url)
        results &lt;- result
    }
}

func main() {
    urls := []string{
        &#34;https://golang.org&#34;,
        &#34;https://github.com&#34;,
        &#34;https://stackoverflow.com&#34;,
        &#34;https://reddit.com&#34;,
        &#34;https://twitter.com&#34;,
    }
    
    numWorkers := 3
    urlsChan := make(chan string, len(urls))
    results := make(chan Result, len(urls))
    
    var wg sync.WaitGroup
    
    // Start workers
    for i := 1; i &lt;= numWorkers; i++ {
        wg.Add(1)
        go worker(i, urlsChan, results, &amp;wg)
    }
    
    // Send URLs
    for _, url := range urls {
        urlsChan &lt;- url
    }
    close(urlsChan)
    
    // Wait for workers
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Collect results
    fmt.Println(&#34;\n=== Results ===&#34;)
    for result := range results {
        if result.Error != nil {
            fmt.Printf(&#34;❌ %s: %v\n&#34;, result.URL, result.Error)
        } else {
            fmt.Printf(&#34;✅ %s: %d bytes (status: %d)\n&#34;, 
                result.URL, result.Size, result.Status)
        }
    }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Ringkasan" duration="5">
        <p>Selamat! Anda telah mempelajari:</p>
<ul>
<li>✅ Goroutines</li>
<li>✅ Channels (buffered &amp; unbuffered)</li>
<li>✅ Select statement</li>
<li>✅ Channel directions</li>
<li>✅ Worker pools</li>
<li>✅ Context package</li>
<li>✅ Race conditions</li>
<li>✅ Common patterns</li>
</ul>
<h2 is-upgraded>Phase 1 Complete!</h2>
<p>Anda sudah menyelesaikan Phase 1: Core Backend with Go!</p>
<ul>
<li>✅ 1.1 Basic Go</li>
<li>✅ 1.2 HTTP &amp; REST API</li>
<li>✅ 1.3 Packages &amp; Modules</li>
<li>✅ 1.4 Concurrency &amp; Goroutines</li>
</ul>
<h2 is-upgraded>Langkah Selanjutnya</h2>
<ul>
<li><strong>Phase 2</strong>: PostgreSQL &amp; Redis</li>
<li>Database integration</li>
<li>Caching strategies</li>
<li>ORM dengan GORM</li>
</ul>
<h2 is-upgraded>Resources</h2>
<ul>
<li><a href="https://go.dev/blog/pipelines" target="_blank">Go Concurrency Patterns</a></li>
<li><a href="https://go.dev/doc/effective_go" target="_blank">Effective Go</a></li>
<li><a href="https://gobyexample.com/goroutines" target="_blank">Go by Example: Goroutines</a></li>
</ul>
<p>Positive : Selamat menyelesaikan Phase 1! Lanjut ke Phase 2 untuk belajar database! 🎉</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
